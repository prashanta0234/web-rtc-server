<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webinar System Client Example</title>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <script src="https://unpkg.com/mediasoup-client@3/dist/mediasoup-client.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 300px;
        gap: 20px;
      }
      .video-container {
        background: #000;
        border-radius: 8px;
        overflow: hidden;
      }
      .video-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 10px;
        padding: 10px;
      }
      video {
        width: 100%;
        height: 200px;
        object-fit: cover;
        border-radius: 4px;
      }
      .controls {
        background: #f5f5f5;
        padding: 15px;
        border-radius: 8px;
      }
      .chat-container {
        background: #f9f9f9;
        border-radius: 8px;
        padding: 15px;
        height: 600px;
        display: flex;
        flex-direction: column;
      }
      .chat-messages {
        flex: 1;
        overflow-y: auto;
        margin-bottom: 15px;
        padding: 10px;
        background: white;
        border-radius: 4px;
      }
      .chat-input {
        display: flex;
        gap: 10px;
      }
      .chat-input input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .chat-input button {
        padding: 8px 16px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .chat-input button:hover {
        background: #0056b3;
      }
      .message {
        margin-bottom: 8px;
        padding: 8px;
        background: #e9ecef;
        border-radius: 4px;
      }
      .message .sender {
        font-weight: bold;
        color: #495057;
      }
      .message .content {
        margin-top: 4px;
      }
      .message .timestamp {
        font-size: 0.8em;
        color: #6c757d;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .btn-primary {
        background: #007bff;
        color: white;
      }
      .btn-success {
        background: #28a745;
        color: white;
      }
      .btn-danger {
        background: #dc3545;
        color: white;
      }
      .btn-warning {
        background: #ffc107;
        color: #212529;
      }
      input,
      select {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        font-weight: bold;
      }
      .status.connected {
        background: #d4edda;
        color: #155724;
      }
      .status.disconnected {
        background: #f8d7da;
        color: #721c24;
      }
    </style>
  </head>
  <body>
    <h1>Webinar System Client Example</h1>

    <div class="status disconnected" id="connectionStatus">Disconnected</div>

    <div class="controls">
      <h3>Connection Setup</h3>
      <input
        type="text"
        id="serverUrl"
        placeholder="Server URL"
        value="http://localhost:5050"
      />
      <input type="text" id="roomId" placeholder="Room ID" value="room123" />
      <input
        type="text"
        id="participantName"
        placeholder="Your Name"
        value="John Doe"
      />
      <select id="participantRole">
        <option value="host">Host</option>
        <option value="speaker">Speaker</option>
        <option value="participant">Participant</option>
      </select>
      <button class="btn-primary" onclick="connect()">Connect</button>
      <button class="btn-danger" onclick="disconnect()">Disconnect</button>
    </div>

    <div class="container">
      <div class="video-container">
        <h3>Video Streams</h3>
        <div class="video-grid" id="videoGrid">
          <video id="localVideo" autoplay muted playsinline></video>
        </div>
        <div class="controls">
          <button class="btn-warning" onclick="toggleMute()">
            Mute/Unmute
          </button>
          <button class="btn-warning" onclick="toggleVideo()">
            Start/Stop Video
          </button>
          <button class="btn-success" onclick="startScreenShare()">
            Share Screen
          </button>
        </div>
      </div>

      <div class="chat-container">
        <h3>Chat</h3>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input">
          <input
            type="text"
            id="messageInput"
            placeholder="Type a message..."
            onkeypress="handleKeyPress(event)"
          />
          <button onclick="sendMessage()">Send</button>
        </div>
      </div>
    </div>

    <script>
      let socket;
      let chatSocket;
      let device;
      let sendTransport;
      let recvTransport;
      let localStream;
      let producers = new Map();
      let consumers = new Map();
      let isConnected = false;
      let isMuted = false;
      let isVideoEnabled = true;

      // Connection management
      async function connect() {
        const serverUrl = document.getElementById('serverUrl').value;
        const roomId = document.getElementById('roomId').value;
        const participantName =
          document.getElementById('participantName').value;
        const role = document.getElementById('participantRole').value;

        try {
          // Connect to main WebRTC socket
          socket = io(serverUrl);

          socket.on('connect', () => {
            console.log('Connected to WebRTC server');
            updateConnectionStatus(true);

            // Join room
            socket.emit('join-room', {
              roomId,
              participantName,
              role,
            });
          });

          socket.on('disconnect', () => {
            console.log('Disconnected from WebRTC server');
            updateConnectionStatus(false);
          });

          // Connect to chat socket
          chatSocket = io(`${serverUrl}/chat`);

          chatSocket.on('connect', () => {
            console.log('Connected to chat server');

            // Join chat
            chatSocket.emit('join-chat', {
              roomId,
              participantId: socket.id,
              participantName,
            });
          });

          // WebRTC event handlers
          socket.on('participant-joined', handleParticipantJoined);
          socket.on('participant-left', handleParticipantLeft);
          socket.on('new-producer', handleNewProducer);

          // Chat event handlers
          chatSocket.on('chat-history', handleChatHistory);
          chatSocket.on('new-message', handleNewMessage);
          chatSocket.on('participants-list', handleParticipantsList);

          // Initialize WebRTC
          await initializeWebRTC(roomId);
        } catch (error) {
          console.error('Connection error:', error);
          alert('Failed to connect: ' + error.message);
        }
      }

      function disconnect() {
        if (socket) {
          socket.disconnect();
        }
        if (chatSocket) {
          chatSocket.disconnect();
        }
        updateConnectionStatus(false);
        cleanupWebRTC();
      }

      function updateConnectionStatus(connected) {
        isConnected = connected;
        const statusElement = document.getElementById('connectionStatus');
        statusElement.textContent = connected ? 'Connected' : 'Disconnected';
        statusElement.className = `status ${connected ? 'connected' : 'disconnected'}`;
      }

      // WebRTC initialization
      async function initializeWebRTC(roomId) {
        try {
          // Get router RTP capabilities
          const { rtpCapabilities } = await emitAndWait(
            socket,
            'get-router-rtp-capabilities',
            { roomId },
          );

          // Create device
          device = new MediasoupClient.Device();
          await device.load({ routerRtpCapabilities: rtpCapabilities });

          // Create send transport
          const { params: sendParams } = await emitAndWait(
            socket,
            'create-transport',
            {
              roomId,
              direction: 'send',
            },
          );

          sendTransport = device.createSendTransport(sendParams);

          sendTransport.on(
            'connect',
            async ({ dtlsParameters }, callback, errback) => {
              try {
                await emitAndWait(socket, 'connect-transport', {
                  roomId,
                  transportId: sendTransport.id,
                  dtlsParameters,
                });
                callback();
              } catch (error) {
                errback(error);
              }
            },
          );

          sendTransport.on(
            'produce',
            async ({ kind, rtpParameters, appData }, callback, errback) => {
              try {
                const { producerId } = await emitAndWait(socket, 'produce', {
                  roomId,
                  transportId: sendTransport.id,
                  kind,
                  rtpParameters,
                  appData,
                });
                callback({ id: producerId });
              } catch (error) {
                errback(error);
              }
            },
          );

          // Create receive transport
          const { params: recvParams } = await emitAndWait(
            socket,
            'create-transport',
            {
              roomId,
              direction: 'recv',
            },
          );

          recvTransport = device.createRecvTransport(recvParams);

          recvTransport.on(
            'connect',
            async ({ dtlsParameters }, callback, errback) => {
              try {
                await emitAndWait(socket, 'connect-transport', {
                  roomId,
                  transportId: recvTransport.id,
                  dtlsParameters,
                });
                callback();
              } catch (error) {
                errback(error);
              }
            },
          );

          // Get user media
          localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });

          const localVideo = document.getElementById('localVideo');
          localVideo.srcObject = localStream;

          // Produce local streams
          await produceMedia('audio');
          await produceMedia('video');
        } catch (error) {
          console.error('WebRTC initialization error:', error);
          throw error;
        }
      }

      async function produceMedia(kind) {
        try {
          const track = localStream.getTracks().find((t) => t.kind === kind);
          if (!track) return;

          const producer = await sendTransport.produce({
            track,
            encodings:
              kind === 'video'
                ? [
                    { maxBitrate: 1000000, scalabilityMode: 'S3T3' },
                    { maxBitrate: 500000, scalabilityMode: 'S2T3' },
                    { maxBitrate: 150000, scalabilityMode: 'S1T3' },
                  ]
                : undefined,
            codecOptions:
              kind === 'video'
                ? {
                    videoGoogleStartBitrate: 1000,
                  }
                : undefined,
          });

          producers.set(kind, producer);
          console.log(`${kind} producer created:`, producer.id);
        } catch (error) {
          console.error(`Error producing ${kind}:`, error);
        }
      }

      async function consumeMedia(producerId, kind) {
        try {
          const { params } = await emitAndWait(socket, 'consume', {
            roomId: document.getElementById('roomId').value,
            transportId: recvTransport.id,
            producerId,
            rtpCapabilities: device.rtpCapabilities,
          });

          const consumer = await recvTransport.consume(params);
          consumers.set(consumer.id, consumer);

          // Create video element for remote stream
          const video = document.createElement('video');
          video.id = `video-${producerId}`;
          video.autoplay = true;
          video.playsinline = true;

          const stream = new MediaStream([consumer.track]);
          video.srcObject = stream;

          document.getElementById('videoGrid').appendChild(video);

          console.log(`${kind} consumer created:`, consumer.id);
        } catch (error) {
          console.error(`Error consuming ${kind}:`, error);
        }
      }

      // Media controls
      function toggleMute() {
        if (!localStream) return;

        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          isMuted = !audioTrack.enabled;
          console.log('Audio track enabled:', audioTrack.enabled);
        }
      }

      function toggleVideo() {
        if (!localStream) return;

        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          isVideoEnabled = videoTrack.enabled;
          console.log('Video track enabled:', videoTrack.enabled);
        }
      }

      async function startScreenShare() {
        try {
          const screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: true,
          });

          const videoTrack = screenStream.getVideoTracks()[0];
          if (videoTrack) {
            const producer = await sendTransport.produce({
              track: videoTrack,
              encodings: [
                { maxBitrate: 1000000, scalabilityMode: 'S3T3' },
                { maxBitrate: 500000, scalabilityMode: 'S2T3' },
                { maxBitrate: 150000, scalabilityMode: 'S1T3' },
              ],
              codecOptions: {
                videoGoogleStartBitrate: 1000,
              },
            });

            producers.set('screen', producer);
            console.log('Screen share producer created:', producer.id);
          }
        } catch (error) {
          console.error('Error starting screen share:', error);
        }
      }

      // Event handlers
      function handleParticipantJoined(data) {
        console.log('Participant joined:', data);
      }

      function handleParticipantLeft(data) {
        console.log('Participant left:', data);
        // Remove video element if exists
        const video = document.getElementById(`video-${data.participantId}`);
        if (video) {
          video.remove();
        }
      }

      function handleNewProducer(data) {
        console.log('New producer:', data);
        consumeMedia(data.producerId, data.kind);
      }

      function handleChatHistory(messages) {
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.innerHTML = '';

        messages.forEach((message) => {
          addMessageToChat(message);
        });
      }

      function handleNewMessage(message) {
        addMessageToChat(message);
      }

      function handleParticipantsList(participants) {
        console.log('Participants:', participants);
      }

      function addMessageToChat(message) {
        const chatMessages = document.getElementById('chatMessages');
        const messageElement = document.createElement('div');
        messageElement.className = 'message';
        messageElement.innerHTML = `
                <div class="sender">${message.senderName}</div>
                <div class="content">${message.content}</div>
                <div class="timestamp">${new Date(message.timestamp).toLocaleTimeString()}</div>
            `;
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Chat functions
      function sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();

        if (message && chatSocket) {
          chatSocket.emit('send-message', {
            roomId: document.getElementById('roomId').value,
            message: {
              content: message,
              type: 'text',
            },
            senderId: socket.id,
            senderName: document.getElementById('participantName').value,
          });
          input.value = '';
        }
      }

      function handleKeyPress(event) {
        if (event.key === 'Enter') {
          sendMessage();
        }
      }

      // Utility functions
      function emitAndWait(socket, event, data) {
        return new Promise((resolve, reject) => {
          socket.emit(event, data, (response) => {
            if (response.success) {
              resolve(response);
            } else {
              reject(new Error(response.error || 'Request failed'));
            }
          });
        });
      }

      function cleanupWebRTC() {
        // Close producers
        producers.forEach((producer) => producer.close());
        producers.clear();

        // Close consumers
        consumers.forEach((consumer) => consumer.close());
        consumers.clear();

        // Close transports
        if (sendTransport) {
          sendTransport.close();
          sendTransport = null;
        }
        if (recvTransport) {
          recvTransport.close();
          recvTransport = null;
        }

        // Stop local stream
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }

        // Clear video elements
        const videoGrid = document.getElementById('videoGrid');
        videoGrid.innerHTML =
          '<video id="localVideo" autoplay muted playsinline></video>';
      }
    </script>
  </body>
</html>
